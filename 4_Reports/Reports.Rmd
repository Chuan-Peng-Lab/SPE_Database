---
title: "Self-Prioritization Effects Database"
author: "Author First M. Last"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
  pdf_document:
    toc: true
    number_sections: true
---

# Abstract

Self-Prioritization Effects play an important role in helping us understand how self-relevance influences human actions and thoughts. To better understand this process, we created a large database of Self-Prioritization Effects studies based on Sui's paradigm. The data from each study are structured in a common, easy-to-use format that can be imported and analyzed using multiple software packages. Each dataset is accompanied by an explanation regarding the nature of the collected data. As of publication, the Self-Prioritization Effects Database (available at [GitHub Repository](https://github.com/Chuan-Peng-Lab/SPE_Database)) contains 145 datasets with data from more than 8,700 participants. We demonstrate the usefulness of this collection in four analyses that provide precise estimations of several foundational self-related effects.

**Keywords**: Self-Prioritization Effects; Database

## Introduction

Recently, more and more researchers have become interested in how self-relevance influences human actions and thoughts. An elegant experimental paradigm (Sui et al., 2012) shows that when stimuli are related to ourselves, we tend to respond with greater accuracy and speed. For example, when the concept of "me" is associated with a triangle, recognition is faster and more accurate than when the shape is associated with "others". This suggests that the self-concept has priority in early perceptual processing, known as the Self-Prioritization Effect (SPE) in shape-label matching tasks.

## Details of the Database

The Self-Prioritization Effects Database is hosted on the [Open Science Framework (OSF)](https://osf.io/s46pr/) website. Each dataset is represented by two folders: **Raw_Data** and **Clean_Data**.

-   The **Raw_Data** folder contains the original data from the study.
-   The **Clean_Data** folder includes processed data files in `.csv` format and a corresponding codebook in `.xlsx` format.

Each study includes a README file, which outlines the authors, citation, participants, procedure, and data files.

## Example Uses of the Database

The Self-Prioritization Effects Database can be used for a variety of purposes, such as: 1. Developing and testing new models of Self-Prioritization Effects. 2. Comparing the effects of different demographic variables on SPE (e.g., gender, nationality, area). 3. Replicating studies to validate findings. 4. Conducting meta-analyses to estimate the size of SPE across different tasks and populations.

Below are some example analyses demonstrating the utility of the database.

## Analysis Example 1: Reaction Time and Accuracy

```{r}
# 加载必要的库
library(dplyr)
library(ggplot2)

# 假设 df 是一个包含文章数据的列表，其中每个元素都是一个数据框
# df 是一个列表，df[[n]] 是第 n 篇文章，里面包含数据

# 定义一些变量来存储统计信息
all_data <- data.frame()  # 用于存储所有文章的人口统计学和 RT 数据
gender_count_list <- list()  # 存储每篇文章的性别统计信息
age_data <- c()  # 存储所有年龄信息

# 性别统一化函数
standardize_gender <- function(gender) {
  gender <- tolower(gender)  # 转换为小写
  if (gender %in% c("1", "m", "M", "Mann", "Hombre", "male", "Male")) {
    return("Male")
  } else if (gender %in% c("2", "f", "F", "Frau", "Mujer", "female", "Female")) {
    return("Female")
  } else {
    return("Others")
  }
}

# 遍历每篇文章的数据
for (i in 1:length(df)) {
  article_data <- df[[i]]  # 获取每篇文章的数据
  
  # 只选择我们关心的列，如 Subject、Gender、Age 和 RT_ms，其他的列忽略
  article_data_filtered <- article_data %>%
    select(any_of(c("Subject", "Gender", "Age", "RT_ms")))  # 只选择这些列，如果不存在则忽略
  
  # 确保 Subject 列为字符类型，Gender 列为字符类型，Age 列统一为数值类型
  if ("Subject" %in% colnames(article_data_filtered)) {
    article_data_filtered$Subject <- as.character(article_data_filtered$Subject)
  }
  
  if ("Gender" %in% colnames(article_data_filtered)) {
    article_data_filtered$Gender <- as.character(article_data_filtered$Gender)
    article_data_filtered$Gender <- sapply(article_data_filtered$Gender, standardize_gender)  # 统一化性别变量
  }
  
  if ("Age" %in% colnames(article_data_filtered)) {
    article_data_filtered$Age <- as.numeric(as.character(article_data_filtered$Age))
  }
  
  # 为每篇文章中的被试编号添加文章索引前缀，使每个被试编号在全局范围内唯一
  article_data_filtered <- article_data_filtered %>%
    mutate(Subject = paste0("Article", i, "_", Subject))
  
  # 统计性别
  if ("Gender" %in% colnames(article_data_filtered)) {
    current_gender_count <- table(article_data_filtered$Gender)
    gender_count_list[[i]] <- current_gender_count
  }
  
  # 收集年龄数据
  if ("Age" %in% colnames(article_data_filtered)) {
    age_data <- c(age_data, article_data_filtered$Age)
  }
  
  # 将每篇文章的数据合并，只合并过滤后的数据
  all_data <- bind_rows(all_data, article_data_filtered)
}

# 合并所有文章的性别统计
gender_count <- Reduce(`+`, gender_count_list, init = table(factor(levels = unique(unlist(lapply(gender_count_list, names))))))

# 人口统计学描述
total_subjects <- nrow(all_data)  # 被试总人数
male_count <- sum(all_data$Gender == "Male", na.rm = TRUE)  # 男性数量
female_count <- sum(all_data$Gender == "Female", na.rm = TRUE)  # 女性数量
avg_age <- mean(age_data, na.rm = TRUE)  # 平均年龄

# 输出人口统计学信息
cat("总被试量: ", total_subjects, "\n")
cat("男性数量: ", male_count, "\n")
cat("女性数量: ", female_count, "\n")
cat("平均年龄: ", avg_age, "\n")

# 分别绘制 Age 和 RT_ms 的散点图

# 绘制 Age 的散点图，X 轴为 Subject，Y 轴为 Age
ggplot(all_data, aes(x = Subject, y = Age, color = Gender)) +
  geom_point(alpha = 0.7) +
  labs(title = "Scatter Plot of Age by Subject",
       x = "Subject",
       y = "Age",
       color = "Gender") +
  theme_minimal() +
  theme(axis.text.x = element_blank())  # 隐藏 X 轴的文本

# 绘制 RT_ms 的散点图，X 轴为 Subject，Y 轴为 RT_ms
ggplot(all_data, aes(x = Subject, y = RT_ms, color = Gender)) +
  geom_point(alpha = 0.7) +
  labs(title = "Scatter Plot of RT_ms by Subject",
       x = "Subject",
       y = "RT_ms",
       color = "Gender") +
  theme_minimal() +
  theme(axis.text.x = element_blank())  # 隐藏 X 轴的文本

# 如果有 RT_ms 数据，对其进行统计
if ("RT_ms" %in% colnames(all_data)) {
  rt_summary <- summary(all_data$RT_ms)
  cat("RT_ms 描述统计: \n")
  print(rt_summary)
}

# 清理环境变量
rm(subject_df, age_data, avg_age, current_gender_count, female_count, gender_count, i, male_count, rt_summary, subject_bins, subject_distribution, total_subjects, all_data, article_data, article_data_filtered, gender_count_list)


```



```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# 假设df是一个包含多篇论文数据的列表

# 1. 计算每个被试的平均ACC和RT_ms
plot_data <- lapply(df, function(data) {
  if ("Identity" %in% names(data) && "Matching" %in% names(data)) {
    data %>%
      mutate(Identity = case_when(
        Identity == "Self" ~ "Self",
        Identity == "P1" ~ "Self",
        Identity == "Friend" ~ "Friend",
        Identity == "Close" ~ "Close",
        Identity == "Mother" ~ "Close",
        Identity == "Father" ~ "Close",
        Identity == "Familiar" ~ "Close",
        Identity == "Acquaintance" ~ "Close",
        Identity == "P2" ~ "Close",
        TRUE ~ "Others"  # 其他归为Others
      )) %>%
      group_by(Identity, Matching) %>%
      summarise(mean_ACC = mean(ACC, na.rm = TRUE), 
                mean_RT_ms = mean(RT_ms, na.rm = TRUE), 
                .groups = "drop")
  } else {
    return(NULL)  # 如果缺少列，返回NULL
  }
})

# 合并数据用于绘图，去除NULL值
plot_df <- bind_rows(plot_data, .id = "paper") %>% na.omit()

# 散点图，绘制存在的数据
ggplot(plot_df, aes(x = mean_ACC, y = mean_RT_ms, shape = Identity)) +
  geom_point(size = 3) +
  labs(x = "平均ACC", y = "平均RT (ms)") +
  theme_minimal()

# 2. 统计每篇论文的被试量及性别
subject_counts <- lapply(df, function(data) {
  if ("Subject" %in% names(data) && "Gender" %in% names(data)) {
    data %>%
      distinct(Subject, Gender) %>%
      summarise(
        total_subjects = n_distinct(Subject),
        male_count = sum(Gender == "Male", na.rm = TRUE),
        female_count = sum(Gender == "Female", na.rm = TRUE),
        .groups = "drop"
      )
  } else {
    return(NULL)  # 如果缺少列，返回NULL
  }
})

# 转换为数据框，去除NULL值
subject_counts_df <- do.call(rbind, subject_counts) %>% na.omit()

# 输出结果
print(subject_counts_df)

```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# 假设df是一个包含多篇论文数据的列表

# 1. 计算每个被试的平均ACC和RT_ms
plot_data <- lapply(df, function(data) {
  if ("Identity" %in% names(data) && "Matching" %in% names(data)) {
    data %>%
      mutate(Identity = case_when(
        Identity == "Self" ~ "Self",
        # Identity == "P1" ~ "Self",
        Identity == "Friend" ~ "Friend",
        Identity == "Close" ~ "Close",
        Identity == "Mother" ~ "Close",
        Identity == "Father" ~ "Close",
        Identity == "Familiar" ~ "Close",
        Identity == "Acquaintance" ~ "Close",
        # Identity == "P2" ~ "Close",
        TRUE ~ "Others"
      )) %>%
      group_by(Identity, Matching) %>%
      summarise(mean_ACC = mean(ACC, na.rm = TRUE), 
                mean_RT_ms = mean(RT_ms, na.rm = TRUE), 
                .groups = "drop")
  } else {
    return(NULL)
  }
})

# 合并数据用于绘图，去除NULL值
plot_df <- bind_rows(plot_data, .id = "paper") %>% na.omit()

# 绘制Matching条件下的散点图
ggplot(plot_df %>% filter(Matching == "Matching"), aes(x = mean_ACC, y = mean_RT_ms, shape = Identity)) +
  geom_point(size = 3) +
  labs(x = "ACC (Matching)", y = "RT (ms)") +
  theme_minimal()

# 绘制Nonmatching条件下的散点图
ggplot(plot_df %>% filter(Matching == "Nonmatching"), aes(x = mean_ACC, y = mean_RT_ms, shape = Identity)) +
  geom_point(size = 3) +
  labs(x = "ACC (Nonmatching)", y = "RT (ms)") +
  theme_minimal()

# 2. 统计每篇论文的被试量及性别
subject_counts <- lapply(df, function(data) {
  if ("Subject" %in% names(data) && "Gender" %in% names(data)) {
    data %>%
      distinct(Subject, Gender) %>%
      summarise(
        total_subjects = n_distinct(Subject),
        male_count = sum(Gender == "Male", na.rm = TRUE),
        female_count = sum(Gender == "Female", na.rm = TRUE),
        .groups = "drop"
      )
  } else {
    return(NULL)
  }
})

# 转换为数据框，去除NULL值
subject_counts_df <- do.call(rbind, subject_counts) %>% na.omit()

# 输出结果
print(subject_counts_df)

```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# 假设df是一个包含多篇论文数据的列表

# 1. 计算每个被试的平均ACC和RT_ms
plot_data <- lapply(df, function(data) {
  if ("Identity" %in% names(data) && "Matching" %in% names(data) && "Subject" %in% names(data)) {
    data %>%
      mutate(Identity = case_when(
        Identity == "Self" ~ "Self",
        Identity == "P1" ~ "Self",
        Identity == "Friend" ~ "Friend",
        Identity == "Close" ~ "Close",
        Identity == "Mother" ~ "Close",
        Identity == "Father" ~ "Close",
        Identity == "Familiar" ~ "Close",
        Identity == "Acquaintance" ~ "Close",
        Identity == "P2" ~ "Close",
        TRUE ~ "Others"
      )) %>%
      group_by(Subject, Identity, Matching) %>%
      summarise(mean_ACC = mean(ACC, na.rm = TRUE), 
                mean_RT_ms = mean(RT_ms, na.rm = TRUE), 
                .groups = "drop")
  } else {
    return(NULL)
  }
})

# 合并数据用于绘图，去除NULL值
plot_df <- bind_rows(plot_data, .id = "paper") %>% na.omit()

# 绘制Matching条件下的散点图
ggplot(plot_df %>% filter(Matching == "Matching"), aes(x = mean_ACC, y = mean_RT_ms, shape = Identity)) +
  geom_point(size = 3) +
  labs(x = "平均ACC (Matching)", y = "平均RT (ms)") +
  theme_minimal()

# 绘制Nonmatching条件下的散点图
ggplot(plot_df %>% filter(Matching == "Nonmatching"), aes(x = mean_ACC, y = mean_RT_ms, shape = Identity)) +
  geom_point(size = 3) +
  labs(x = "平均ACC (Nonmatching)", y = "平均RT (ms)") +
  theme_minimal()

# 2. 统计每篇论文的被试量及性别
subject_counts <- lapply(df, function(data) {
  if ("Subject" %in% names(data) && "Gender" %in% names(data)) {
    data %>%
      distinct(Subject, Gender) %>%
      summarise(
        total_subjects = n_distinct(Subject),
        male_count = sum(Gender == "Male", na.rm = TRUE),
        female_count = sum(Gender == "Female", na.rm = TRUE),
        .groups = "drop"
      )
  } else {
    return(NULL)
  }
})

# 转换为数据框，去除NULL值
subject_counts_df <- do.call(rbind, subject_counts) %>% na.omit()

# 输出结果
print(subject_counts_df)

```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# 假设df是一个包含多篇论文数据的列表

# 1. 计算每个被试的平均ACC和RT_ms
plot_data <- lapply(df, function(data) {
  if ("Identity" %in% names(data) && "Matching" %in% names(data) && "Subject" %in% names(data)) {
    data %>%
      mutate(Identity = case_when(
        Identity == "Self" ~ "Self",
        Identity == "P1" ~ "Self",
        Identity == "Friend" ~ "Friend",
        Identity == "Close" ~ "Close",
        Identity == "Mother" ~ "Close",
        Identity == "Father" ~ "Close",
        Identity == "Familiar" ~ "Close",
        Identity == "Acquaintance" ~ "Close",
        Identity == "P2" ~ "Close",
        TRUE ~ "Others"
      )) %>%
      group_by(Subject, Identity, Matching) %>%
      summarise(mean_ACC = mean(pmin(pmax(ACC, 0), 1), na.rm = TRUE),
                mean_RT_ms = mean(RT_ms, na.rm = TRUE),
                .groups = "drop")
  } else {
    return(NULL)
  }
})

# 合并数据用于绘图，去除NULL值
plot_df <- bind_rows(plot_data, .id = "paper") %>% na.omit()

# 自定义形状和颜色
shape_values <- c("Self" = 1, "Friend" = 17, "Close" = 15, "Others" = 3)
color_values <- c("Self" = "black", "Friend" = "gray", "Close" = "lightgray", "Others" = "#A9A9A9")

# 绘制Matching条件下的散点图
ggplot(plot_df %>% filter(Matching == "Matching"), aes(x = mean_ACC, y = mean_RT_ms, shape = Identity, color = Identity)) +
  geom_point(size = 3) +
  scale_shape_manual(values = shape_values) +
  scale_color_manual(values = color_values) +
  labs(x = "平均ACC (Matching)", y = "平均RT (ms)") +
  theme_minimal()

# 绘制Nonmatching条件下的散点图
ggplot(plot_df %>% filter(Matching == "Nonmatching"), aes(x = mean_ACC, y = mean_RT_ms, shape = Identity, color = Identity)) +
  geom_point(size = 3) +
  scale_shape_manual(values = shape_values) +
  scale_color_manual(values = color_values) +
  labs(x = "平均ACC (Nonmatching)", y = "平均RT (ms)") +
  theme_minimal()

# 2. 统计每篇论文的被试量及性别
subject_counts <- lapply(df, function(data) {
  if ("Subject" %in% names(data) && "Gender" %in% names(data)) {
    data %>%
      distinct(Subject, Gender) %>%
      summarise(
        total_subjects = n_distinct(Subject),
        male_count = sum(Gender == "Male", na.rm = TRUE),
        female_count = sum(Gender == "Female", na.rm = TRUE),
        .groups = "drop"
      )
  } else {
    return(NULL)
  }
})

# 转换为数据框，去除NULL值
subject_counts_df <- do.call(rbind, subject_counts) %>% na.omit()

# 输出结果
print(subject_counts_df)

```


```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# 假设df是一个包含多篇论文数据的列表

# 合并数据并处理Identity
plot_data <- bind_rows(lapply(df, function(data) {
  if ("Identity" %in% names(data) && "Matching" %in% names(data) && "Subject" %in% names(data)) {
    data %>%
      mutate(Identity = case_when(
        Identity == "Self" ~ "Self",
        Identity == "P1" ~ "Self",
        Identity == "Friend" ~ "Friend",
        Identity == "Close" ~ "Close",
        Identity == "Mother" ~ "Close",
        Identity == "Father" ~ "Close",
        Identity == "Familiar" ~ "Close",
        Identity == "Acquaintance" ~ "Close",
        Identity == "P2" ~ "Close",
        TRUE ~ "Others"
      ))
  } else {
    return(NULL)
  }
}))

# 自定义形状和颜色
shape_values <- c("Self" = 1, "Friend" = 17, "Close" = 15, "Others" = 3)
color_values <- c("Self" = "lightgray", "Friend" = "gray", "Close" = "#A9A9A9", "Others" = "black")

# 绘制Matching条件下的散点图
ggplot(plot_data %>% filter(Matching == "Matching"), aes(x = ACC, y = RT_ms, shape = Identity, color = Identity)) +
  stat_summary(fun = mean, geom = "point", size = 3) +
  scale_shape_manual(values = shape_values) +
  scale_color_manual(values = color_values) +
  labs(x = "平均ACC (Matching)", y = "平均RT (ms)") +
  theme_minimal()

# 绘制Nonmatching条件下的散点图
ggplot(plot_data %>% filter(Matching == "Nonmatching"), aes(x = ACC, y = RT_ms, shape = Identity, color = Identity)) +
  stat_summary(fun = mean, geom = "point", size = 3) +
  scale_shape_manual(values = shape_values) +
  scale_color_manual(values = color_values) +
  labs(x = "平均ACC (Nonmatching)", y = "平均RT (ms)") +
  theme_minimal()

# 2. 统计每篇论文的被试量及性别
subject_counts <- lapply(df, function(data) {
  if ("Subject" %in% names(data) && "Gender" %in% names(data)) {
    data %>%
      distinct(Subject, Gender) %>%
      summarise(
        total_subjects = n_distinct(Subject),
        male_count = sum(Gender == "Male", na.rm = TRUE),
        female_count = sum(Gender == "Female", na.rm = TRUE),
        .groups = "drop"
      )
  } else {
    return(NULL)
  }
})

# 转换为数据框，去除NULL值
subject_counts_df <- do.call(rbind, subject_counts) %>% na.omit()

# 输出结果
print(subject_counts_df)

```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)


# 假设df是一个包含多篇论文数据的列表

# 合并数据并处理Identity，同时计算每个被试的正确反应数、总反应数和平均反应时间
plot_data <- bind_rows(lapply(df, function(data) {
  if ("Identity" %in% names(data) && "Matching" %in% names(data) && "Subject" %in% names(data)) {
    data <- data %>%
      mutate(Identity = case_when(
        Identity == "Self" ~ "Self",
        Identity == "P1" ~ "Self",
        Identity == "Friend" ~ "Friend",
        Identity == "Close" ~ "Close",
        Identity == "Mother" ~ "Close",
        Identity == "Father" ~ "Close",
        Identity == "Familiar" ~ "Close",
        Identity == "Acquaintance" ~ "Close",
        Identity == "P2" ~ "Close",
        TRUE ~ "Others"
      )) %>%
      group_by(Subject, Identity, Matching) %>%
      summarise(
        correct_count = sum(ACC == 1, na.rm = TRUE),  # 计算正确反应数
        total_count = n(),  # 总记录数
        mean_RT_ms = mean(RT_ms, na.rm = TRUE),  # 计算平均反应时间
        .groups = "drop"
      ) %>%
      mutate(mean_ACC = correct_count / total_count)  # 计算准确率
    return(data)
  } else {
    return(NULL)
  }
})) %>% na.omit()  # 移除缺失值

# 将结果合并为一个数据框
plot_data <- bind_rows(plot_data) %>% na.omit()



# 计算每个被试的平均ACC和平均RT（Matching条件）
average_data_matching <- plot_data %>%
  filter(Matching == "Matching") %>%  # 只选择Matching条件
  group_by(Subject, Identity) %>%
  summarise(
    mean_ACC = mean(mean_ACC, na.rm = TRUE),  # 每个身份的平均ACC
    mean_RT = mean(mean_RT_ms, na.rm = TRUE),  # 每个身份的平均RT
    .groups = "drop"
  )

# 计算每个被试的平均ACC和平均RT（Nonmatching条件）
average_data_nonmatching <- plot_data %>%
  filter(Matching == "Nonmatching") %>%  # 只选择Nonmatching条件
  group_by(Subject, Identity) %>%
  summarise(
    mean_ACC = mean(mean_ACC, na.rm = TRUE),  # 每个身份的平均ACC
    mean_RT = mean(mean_RT_ms, na.rm = TRUE),  # 每个身份的平均RT
    .groups = "drop"
  )

# 定义形状和颜色
shape_values <- c("Self" = 1, "Friend" = 17, "Others" = 4)  # 1: 空心圆，17: 实心三角，4: 小叉
color_values <- c("Self" = "black", "Friend" = "gray", "Others" = "black")

# 绘制Matching条件的散点图
p1 <- ggplot(average_data_matching, aes(x = mean_ACC, y = mean_RT, shape = Identity, color = Identity)) +
  geom_point(size = 3) +
  scale_shape_manual(values = shape_values) +
  scale_color_manual(values = color_values) +
  labs(x = "平均ACC (Matching)", y = "平均RT (ms)", title = "Matching条件下被试的平均ACC与平均RT散点图") +
  theme_minimal()

# 绘制Nonmatching条件的散点图
p2 <- ggplot(average_data_nonmatching, aes(x = mean_ACC, y = mean_RT, shape = Identity, color = Identity)) +
  geom_point(size = 3) +
  scale_shape_manual(values = shape_values) +
  scale_color_manual(values = color_values) +
  labs(x = "平均ACC (Nonmatching)", y = "平均RT (ms)", title = "Nonmatching条件下被试的平均ACC与平均RT散点图") +
  theme_minimal()

# 打印两个图
print(p1)
print(p2)

# 统计每篇论文的被试量及性别
subject_counts <- lapply(df, function(data) {
  if ("Subject" %in% names(data) && "Gender" %in% names(data)) {
    data %>%
      distinct(Subject, Gender) %>%
      summarise(
        total_subjects = n_distinct(Subject),
        male_count = sum(Gender == "Male", na.rm = TRUE),
        female_count = sum(Gender == "Female", na.rm = TRUE),
        .groups = "drop"
      )
  } else {
    return(NULL)
  }
})

# 转换为数据框，去除NULL值
subject_counts_df <- do.call(rbind, subject_counts) %>% na.omit()

# 输出结果
print(subject_counts_df)

```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# 假设df是一个包含多篇论文数据的列表

# 合并数据并处理Identity，同时计算每个被试的正确反应数、总反应数和平均反应时间
plot_data <- bind_rows(lapply(seq_along(df), function(i) {
  data <- df[[i]]
  if ("Identity" %in% names(data) && "Matching" %in% names(data) && "Subject" %in% names(data)) {
    data <- data %>%
      mutate(Identity = case_when(
        Identity == "Self" ~ "Self",
        Identity == "P1" ~ "Self",
        Identity == "Friend" ~ "Friend",
        Identity == "Close" ~ "Close",
        Identity == "Mother" ~ "Close",
        Identity == "Father" ~ "Close",
        Identity == "Familiar" ~ "Close",
        Identity == "Acquaintance" ~ "Close",
        Identity == "P2" ~ "Close",
        TRUE ~ "Others"
      )) %>%
      group_by(Subject, Identity, Matching) %>%
      summarise(
        correct_count = sum(ACC == 1, na.rm = TRUE),  # 计算正确反应数
        total_count = n(),  # 总记录数
        mean_RT_ms = mean(RT_ms, na.rm = TRUE),  # 计算平均反应时间
        .groups = "drop"
      ) %>%
      mutate(mean_ACC = correct_count / total_count)  # 计算准确率
    data$Subject <- paste0("S", seq_along(data$Subject) + sum(sapply(df[1:(i - 1)], function(x) n_distinct(x$Subject))))  # 重新编号
    return(data)
  } else {
    return(NULL)
  }
})) %>% na.omit()  # 移除缺失值

# 计算每个被试的平均ACC和平均RT（Matching条件）
average_data_matching <- plot_data %>%
  filter(Matching == "Matching") %>%
  group_by(Subject, Identity) %>%
  summarise(
    mean_ACC = mean(mean_ACC, na.rm = TRUE),
    mean_RT = mean(mean_RT_ms, na.rm = TRUE),
    .groups = "drop"
  )

# 计算每个被试的平均ACC和平均RT（Nonmatching条件）
average_data_nonmatching <- plot_data %>%
  filter(Matching == "Nonmatching") %>%
  group_by(Subject, Identity) %>%
  summarise(
    mean_ACC = mean(mean_ACC, na.rm = TRUE),
    mean_RT = mean(mean_RT_ms, na.rm = TRUE),
    .groups = "drop"
  )

# 定义形状和颜色
shape_values <- c("Self" = 1, "Friend" = 17, "Others" = 4)
color_values <- c("Self" = "black", "Friend" = "gray", "Others" = "black")

# 绘制Matching条件的散点图
p1 <- ggplot(average_data_matching, aes(x = mean_ACC, y = mean_RT, shape = Identity, color = Identity)) +
  geom_point(size = 3) +
  scale_shape_manual(values = shape_values) +
  scale_color_manual(values = color_values) +
  labs(x = "平均ACC (Matching)", y = "平均RT (ms)", title = "Matching条件下被试的平均ACC与平均RT散点图") +
  theme_minimal()

# 绘制Nonmatching条件的散点图
p2 <- ggplot(average_data_nonmatching, aes(x = mean_ACC, y = mean_RT, shape = Identity, color = Identity)) +
  geom_point(size = 3) +
  scale_shape_manual(values = shape_values) +
  scale_color_manual(values = color_values) +
  labs(x = "平均ACC (Nonmatching)", y = "平均RT (ms)", title = "Nonmatching条件下被试的平均ACC与平均RT散点图") +
  theme_minimal()

# 打印两个图
print(p1)
print(p2)

# 统计每篇论文的被试量及性别
subject_counts <- lapply(df, function(data) {
  if ("Subject" %in% names(data) && "Gender" %in% names(data)) {
    data %>%
      distinct(Subject, Gender) %>%
      summarise(
        total_subjects = n_distinct(Subject),
        male_count = sum(Gender == "Male", na.rm = TRUE),
        female_count = sum(Gender == "Female", na.rm = TRUE),
        .groups = "drop"
      )
  } else {
    return(NULL)
  }
})

# 转换为数据框，去除NULL值
subject_counts_df <- do.call(rbind, subject_counts) %>% na.omit()

# 输出结果
print(subject_counts_df)


```

```{r}
library(ggplot2)
library(dplyr)

# 假设 df、df_d_prime、df_d_paper 已经加载

# 遍历每篇文章
for (n in names(df)) {
  # 获取具体文章的数据
  aRT_msicle_data <- df[[n]]
  d_prime_value <- df_d_prime[[n]]
  
  # 处理数据，排除不合条件的试次
  cleaned_data <- aRT_msicle_data %>%
    filter(ACC >= 0.3, RT_ms <= 10000) %>%
    mutate(d_prime_value = d_prime_value)  # 添加 d' 值作为新列
  
  # 1. 散点图，横坐标是RT_ms，纵坐标是d'
  # p1 <- ggplot(cleaned_data, aes(x = RT_ms, y = d_prime_value)) +
  #   geom_point() +
  #   labs(title = paste("RT_ms vs d' for", n),
  #        x = "RT_ms",
  #        y = "d'") +
  #   theme_minimal()
  # 
  # print(p1)
  # 
  # 2. Matching 条件下的散点图
  matching_data <- cleaned_data %>%
    filter(Matching == "Matching") %>%
    filter(ACC >= 0.5, RT_ms >= 500, RT_ms <= 1000)
  
  p2 <- ggplot(matching_data, aes(x = ACC, y = RT_ms, shape = Identity)) +
    geom_point(size = 3) +
    labs(title = paste("ACC vs RT_ms (Matching) for", n),
         x = "ACC",
         y = "RT_ms") +
    scale_shape_manual(values = c(16, 17, 3)) +  # 16: Circle, 17: Triangle, 3: Cross
    theme_minimal()
  
  print(p2)
  
  # 3. Nonmatching 条件下的散点图
  nonmatching_data <- cleaned_data %>%
    filter(Matching == "Nonmatching") %>%
    filter(ACC >= 0.5, RT_ms >= 500, RT_ms <= 1000)
  
  p3 <- ggplot(nonmatching_data, aes(x = ACC, y = RT_ms, shape = Identity)) +
    geom_point(size = 3) +
    labs(title = paste("ACC vs RT_ms (Nonmatching) for", n),
         x = "ACC",
         y = "RT_ms") +
    scale_shape_manual(values = c(16, 17, 3)) +
    theme_minimal()
  
  print(p3)
  
  # 4. 条形图，横坐标是Identity，纵坐标是d'，并给出误差线
  # identity_dprime <- cleaned_data %>%
  #   group_by(Identity) %>%
  #   summarise(mean_dprime = mean(d_prime_value, na.rm = TRUE),
  #             se_dprime = sd(d_prime_value, na.rm = TRUE) / sqRT_ms(n()))
  # 
  # p4 <- ggplot(identity_dprime, aes(x = Identity, y = mean_dprime)) +
  #   geom_bar(stat = "identity", position = "dodge") +
  #   geom_errorbar(aes(ymin = mean_dprime - se_dprime, ymax = mean_dprime + se_dprime), width = 0.2) +
  #   labs(title = paste("Mean d' by Identity for", n),
  #        x = "Identity",
  #        y = "Mean d'") +
  #   theme_minimal()
  # 
  # print(p4)
}



```


```{r}
library(ggplot2)
library(dplyr)

# 假设 df、df_d_prime、df_d_paper 已经加载

# 创建一个列表保存每篇文章的绘图
plots <- list()

# 遍历每篇文章
for (n in names(df)) {
  # 获取具体文章的数据
  article_data <- df[[n]]
  
  # 确认使用的列名
  if ("Identity" %in% names(article_data) && "Matching" %in% names(article_data) && "RT_ms" %in% names(article_data) && "ACC" %in% names(article_data)) {
    
    # 打印 ACC 的分布
    print(table(article_data$ACC))

    plot_data <- article_data %>%
      mutate(Identity = case_when(
        Identity == "Self" ~ "Self",
        Identity == "Friend" ~ "Friend",
        Identity == "Close" ~ "Close",
        Identity == "Mother" ~ "Close",
        Identity == "Father" ~ "Close",
        Identity == "Familiar" ~ "Close",
        Identity == "Acquaintance" ~ "Close",
        TRUE ~ "Others"
      )) %>%
      group_by(Subject, Matching) %>%
      summarise(
        correct_count = sum(ACC == 1, na.rm = TRUE),  # 计算正确反应数
        total_count = n(),  # 总记录数
        mean_ACC = correct_count / total_count,  # 计算正确率
        mean_RT_ms = mean(RT_ms, na.rm = TRUE),  # 计算平均反应时间
        Identity = first(Identity),  # 获取每个被试的 Identity
        .groups = "drop"
      )
  } else {
    next
  }

  # 检查是否有缺失的 Identity 值
  if (any(is.na(plot_data$Identity))) {
    cat("Skipping article:", n, "due to missing Identity values.\n")
    next
  }
  
  # 处理数据，排除不合条件的试次
  cleaned_data <- plot_data %>%
    filter(mean_ACC >= 0.3, mean_RT_ms <= 10000)

  # 输出 cleaned_data 以检查数据
  print(cleaned_data)

  # 1. Matching 条件下的散点图
  matching_data <- cleaned_data %>%
    filter(Matching == "Matching") %>%
    filter(mean_ACC >= 0.5, mean_RT_ms >= 500, mean_RT_ms <= 1000)
  
  if (nrow(matching_data) > 0) {
    p1 <- ggplot(matching_data, aes(x = mean_ACC, y = mean_RT_ms, shape = Identity)) +
      geom_point(size = 3) +
      labs(title = paste("Mean ACC vs Mean RT_ms (Matching) for", n),
           x = "Mean ACC",
           y = "Mean RT_ms") +
      scale_shape_manual(values = c(16, 17, 3)) +
      theme_minimal()
    
    print(p1)
  }
  
  # 2. Nonmatching 条件下的散点图
  nonmatching_data <- cleaned_data %>%
    filter(Matching == "Nonmatching") %>%
    filter(mean_ACC >= 0.5, mean_RT_ms >= 500, mean_RT_ms <= 1000)
  
  if (nrow(nonmatching_data) > 0) {
    p2 <- ggplot(nonmatching_data, aes(x = mean_ACC, y = mean_RT_ms, shape = Identity)) +
      geom_point(size = 3) +
      labs(title = paste("Mean ACC vs Mean RT_ms (Nonmatching) for", n),
           x = "Mean ACC",
           y = "Mean RT_ms") +
      scale_shape_manual(values = c(16, 17, 3)) +
      theme_minimal()
    
    print(p2)
  }
}


```



## Conclusion

The Self-Prioritization Effects Database provides researchers with a wealth of data to explore the cognitive mechanisms underlying self-relevance. By making these datasets publicly available, we hope to facilitate further research and collaboration in this field.

## References

-   Sui, J., He, X., & Humphreys, G. W. (2012). **Perceptual effects of self-relevance: Evidence from perceptual matching**. *Journal of Experimental Psychology: Human Perception and Performance*, 38(5), 1105-1117. DOI: <https://doi.org/10.1037/a0029792>
